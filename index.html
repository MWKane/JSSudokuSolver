<html>
	<head>
		<title>Solver</title>
		<link rel="stylesheet" href="style.css">
	</head>

	<body>
		<div id="game">
			<table id="grid">

			</table>

			<div id="controls">
				<button onClick="gridImport()">Import</button>
				<button onClick="gridExport()">Export</button>
				<br /><br />
				<button onClick="gridInit()">Init</button>
				<button onClick="gridStep()">Step</button>
				<button onClick="gridCommit()">Commit</button>
			</div>
		</div>

		<script>
			// Global Vars
			var game;

			(function createGrid() {
				// Create the sudoku grid - including candidates
				// This is self-invoking

				const grid = document.getElementById('grid');

				for (let i = 1; i <= 9; i++) {
					// Create 9 rows
					let row = document.createElement('tr');
					row.id = `row${i}`;
					row.className = 'row';
					grid.appendChild(row);

					for (let j = 1; j <= 9; j++) {
						// For each row, create 9 cells
						let cell = document.createElement('td');
						cell.className = 'cell';
						row.appendChild(cell);

						// Each cell needs an input box
						let input = document.createElement('input');
						input.type = 'text';
						input.maxLength = 1;
						input.id = `c${i}${j}`;
						cell.appendChild(input);

						// Each cell needs a candidate table
						let candidates = document.createElement('table');
						candidates.className = 'candidates';
						cell.appendChild(candidates);

						// Populate the candidate table (3x3)
						// First create 3 rows and store them in a 1-indexed array
						let cRow1 = document.createElement('tr');
						let cRow2 = document.createElement('tr');
						let cRow3 = document.createElement('tr');
						let cRows = [null, cRow1, cRow2, cRow3];
						candidates.appendChild(cRow1);
						candidates.appendChild(cRow2);
						candidates.appendChild(cRow3);

						// Then for each candidate
						for (let k = 1; k <= 9; k++) {
							// Create the candidate
							let canRow = document.createElement('td');
							let canDiv = document.createElement('div');
							canDiv.className = 'can';
							canDiv.id = `p${i}${j}${k}`;
							canDiv.innerHTML = k;

							// Append it to a row where
							// 1 to 3 = row 1
							// 4 to 6 = row 2
							// 7 to 9 = row 3
							canRow.appendChild(canDiv);
							cRows[Math.ceil(k / 3)].appendChild(canRow);
						};
					};
				};
			})();


			// =================
			// Button Functions
			// =================

			function gridImport() {
				// Resolve import strings
				// Characters supported as blanks: 0
				// TODO: Consider all non 1-9 characters as blanks
				// TODO: Reset grid before importing - currently assumes grid is empty

				let input = prompt('Input 81 digit string');
				if (!input || input.length != 81) {
					alert('Invalid input string');
					return;
				};

				let digits = input.split('');				
				for (let i = 9; i >= 1; i--) {
					for (let j = 9; j >= 1; j--) {
						let n = parseInt(digits.pop());
						if (n) document.getElementById(`c${i}${j}`).value = n;
					};
				};
			};

			function gridExport() {
				// Export current grid string to console
				// Blanks are exported as 0
				// TODO: Copy to clipboard

				let output = [];
				for (let i = 1; i <= 9; i++) {
					for (let j = 1; j <= 9; j++) {
						output.push(document.getElementById(`c${i}${j}`).value || 0);
					};
				};

				console.log(output.join(''));
				return output.join('');
			};

			// TODO: gridReset()


			// ========================
			// Solver Wrapper Functions
			// ========================

			function gridInit() {
				game = new _Game(gridExport());
				syncCandidates();
			};

			function gridStep() {
				clearHighlighting();
				game.step();
				highlightChanges();
			};

			function gridCommit() {
				clearHighlighting();
				game.commit();
				syncValues();
				syncCandidates();
			};

			// ============
			// UI Functions
			// ============

			function syncCandidates() {
				game.forEachCell(cell => {
					for (let can = 1; can <= 9; can++) {
						let element = document.getElementById(`p${cell.id}${can}`);

						if (cell.candidates.includes(can)) element.style.color = 'black';
							else element.style.color = 'transparent';
					};
				});
			};

			function syncValues() {
				game.forEachCell(cell => {
					if (cell.value) {
						let element = document.getElementById('c' + cell.id);
						if (!element.value) {
							element.value = cell.value;
							element.style.color = 'red';
						};
					};
				});
			}

			function highlightChanges() {
				if (!game.solution) {
					console.log('NO SOLUTION COULD BE FOUND');
					return;
				};

				let s = game.solution;


				// Automatic highlighting first so it can be overriden with technique specific highlighting
				s.changes.forEach(change => {
					let cell = change[0];
					let val = change[1];
					let can = change[2];

					if (val) document.getElementById('p' + cell.id + val).style.backgroundColor = 'lime';
					else {
						let candidates = cell.candidates.filter(c => !can.includes(c));
						candidates.forEach(c => document.getElementById('p' + cell.id + c).style.backgroundColor = 'red')
					};
				});

				switch (s.name) {
					// =====
					// TUPLE
					// =====
					case 'TUPLE':
						console.log(`${(s.type + s.class)} (${s.tuple}): [${s.cells.cellIds()}] ${(s.houseType + s.house)}`);

						s.cells.forEach(cell => {
							s.tuple.forEach(candidate => document.getElementById('p' + cell.id + candidate).style.backgroundColor = 'yellow');
						});
					break;
					
					// ========
					// POINTING
					// ========
					case 'POINTING':
						console.log(`POINTING ${s.class}: [${s.cells.cellIds()}] BOX${s.box}`);
						s.cells.forEach(cell => document.getElementById('p' + cell.id + s.candidate).style.backgroundColor = 'yellow');
					break;

					// ==============
					// LINE REDUCTION
					// ==============
					case 'LINEREDUCTION':
						console.log(`LINE REDUCTION (${s.class}): [${s.cells.cellIds()}] BOX${s.box}`);
						s.cells.forEach(cell => document.getElementById('p' + cell.id + s.candidate).style.backgroundColor = 'yellow');
					break;

					// ====
					// FISH
					// ====
					case 'FISH':
						console.log(`${s.class}: [${s.cells.cellIds()}] (${s.type})`);
						s.cells.forEach(cell => document.getElementById('p' + cell.id + s.candidate).style.backgroundColor = 'yellow');
					break;

					// =====
					// CHAIN
					// =====
					case 'CHAIN':
						console.log(`CHAIN (${s.candidate}): [${s.cells.cellIds()}] RULE${s.rule}`);
						s.cellStates.forEach(arr => {
							let cell = arr[0];
							let state = arr[1];
							let element = document.getElementById('p' + cell.id + s.candidate);
							

							if (s.rule == 1) {
								if (state) element.style.backgroundColor = 'cyan';
								else element.style.backgroundColor = 'pink';
							} else {
								if (state == s.onState) element.style.backgroundColor = 'lime';
								else element.style.backgroundColor = 'red';
							};
						});
					break;
				};
			};

			function clearHighlighting() {
				for (let row = 1; row <= 9; row++) {
					for (let col = 1; col <= 9; col++) {
						let cell = document.getElementById('c' + row + col);
						cell.style.color = 'blue';
						cell.style.backgroundColor = 'transparent';

						for (let can = 1; can <= 9; can++) {
							let candidate = document.getElementById('p' + row + col + can);
							candidate.style.backgroundColor = 'transparent';
						};
					};
				};
			};


		</script>

		<script src="solver.js"></script>
	</body>
</html>